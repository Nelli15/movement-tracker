<template>
  <q-card class="q-ma-sm" style="calc(100vh)">
    <LineChart v-bind="lineChartProps" :height="0" />
  </q-card>
</template>

<script>
import { ref, computed, watch, defineComponent, Ref } from 'vue';
import { useStore } from 'vuex';
import { LineChart, useLineChart } from 'vue-chart-3';
import {
  Chart,
  LineElement,
  PointElement,
  LineController,
  CategoryScale,
  LinearScale,
  Legend,
  Title,
  Tooltip,
  ChartData,
  ChartOptions,
} from 'chart.js';

Chart.register(
  LineElement,
  PointElement,
  LineController,
  CategoryScale,
  LinearScale,
  Legend,
  Title,
  Tooltip
);
export default {
  name: 'mt-LineChart',
  props: ['options'],
  components: { LineChart },
  setup(props) {
    const store = useStore();
    const startDate = computed(() => {
      return props.options.startDate;
    });
    const endDate = computed(() => {
      return props.options.endDate;
    });
    const stats = computed(() => {
      return props.options.stats;
    });
    const trees = computed(() => {
      return props.options ? props.options.trees : [];
    });
    // const  = computed(()=>{return props.options.})
    // const startDate = computed(()=>{return props.options.startDate})
    // const startDate = computed(()=>{return props.options.startDate})
    // const startDate = computed(()=>{return props.options.startDate})
    const movement = computed(() => store.state.movement.movement);
    const trends = ref({});
    // fetch trend for stat
    function fetchTrend({ treeId, statId }) {
      console.log('fetching:', {
        treeId: treeId,
        movId: movement.value.id,
        styleId: statId,
        startDate: startDate.value,
        endDate: endDate.value,
      });
      return store.dispatch('trends/fetchTrend', {
        treeId: treeId,
        movId: movement.value.id,
        styleId: statId,
        startDate: startDate.value,
        endDate: endDate.value,
      });
    }
    // const months = [
    //     { label: 'January', number: 0 },
    //     { label: 'February', number: 1 },
    //     { label: 'March', number: 2 },
    //     { label: 'April', number: 3 },
    //     { label: 'May', number: 4 },
    //     { label: 'June', number: 5 },
    //     { label: 'July', number: 6 },
    //     { label: 'August', number: 7 },
    //     { label: 'September', number: 8 },
    //     { label: 'October', number: 9 },
    //     { label: 'November', number: 10 },
    //     { label: 'December', number: 11 },
    //   ],
    //   month = new Date().getMonth(),
    //   previous = months.splice(0, month);
    // // if you have to use this in a front-end app, you might want to use .concat(...) instead of the spread operator
    // const monthVals = [...previous, ...months];
    // const data = ref([]);
    // const targetData = ref([]);
    // watch(trends, () => {
    //   // loop through the months and get relevant snapshots
    //   var date = new Date();
    //   let l_data = [],
    //     l_labels = [],
    //     l_targetData = [];
    // for (let ii in monthVals) {
    //     var firstDay = new Date(date.getFullYear(), date.getMonth() - ii, 1);
    //     var lastDay = new Date(date.getFullYear(), date.getMonth() - ii + 1, 0);
    //     let el = trend.value.trend
    //       ? trend.value.trend.find((val, ind, arr) => {
    //           return (
    //             val.date > firstDay.getTime() && val.date < lastDay.getTime()
    //           );
    //         })
    //       : null;
    // l_labels.unshift(monthVals[ii].label);
    //     l_data.unshift(
    //       el ? el.value : data[data.length] ? data[data.length] : 0
    //     );
    //     l_targetData.unshift(props.stat.target);
    //   }
    //   // add the current snapshots
    //   l_labels.push('now');
    //   l_data.push(props.stat.total);
    //   l_targetData.push(props.stat.target);
    //   labels.value = l_labels;
    //   data.value = l_data;
    //   targetData.value = l_targetData;
    // });
    function fetchData() {
      trends.value = {};
      console.log(
        !trees.value ||
          trees.value.length <= 0 ||
          !stats.value ||
          stats.value.length <= 0
      );
      if (
        !trees.value ||
        trees.value.length <= 0 ||
        !stats.value ||
        stats.value.length <= 0
      )
        return;
      for (let tree of trees.value) {
        for (let stat of stats.value) {
          fetchTrend({ treeId: tree.id, statId: stat.id }).then((res) => {
            console.log(res);
            trends.value[`${tree.id}-${stat.id}`] = {
              ...res,
              label: stat.label,
            };
          });
        }
      }
    }
    watch(
      props.options,
      () => {
        fetchData();
      },
      { deep: true, immediate: true }
    );
    const getData = computed(() => {
      let labels = [];
      let key = Object.keys(trends.value)[0];
      console.log(key);
      for (let ii in trends.value[key].trend) {
        let d = new Date(trends.value[key].trend[ii].date);
        labels.push(
          `${d.toLocaleString('default', {
            month: 'short',
          })} ${d.getFullYear()}`
        );
      }
      console.log(labels);
      let chartData = {
        labels: labels,
        datasets: [],
      };
      if (Object.keys(trends.value).length <= 0) return chartData;
      let trendId;
      for (trendId in trends.value) {
        let trend = trends.value[trendId];
        let trendData = [];
        let ii;
        for (ii in trend.trend) {
          trendData[ii] = trend.trend[ii].value;
        }
        chartData.datasets.push({
          label: stats.value[trend.styleId]
            ? stats.value[trend.styleId].label
            : 'Not Label Provided',
          data: trendData,
          fill: false,
          borderColor: 'rgb(197, 66, 16)',
          tension: props.options.lineTension,
        });
      }
      return chartData;
    });
    const chartOptions = computed(() => ({
      responsive: true,
      plugins: {
        legend: {
          display: false,
        },
        title: {
          display: true,
          text: props.options ? props.options.title : '',
        },
      },
      scales: {
        y: {
          title: {
            display: true,
            text: props.options ? props.options.yAxis : '',
          },
        },
        x: {
          title: {
            display: true,
            text: props.options ? props.options.xAxis : '',
          },
        },
      },
    }));
    const { lineChartProps } = useLineChart({
      options: chartOptions,
      chartData: getData,
    });
    return {
      getData,
      lineChartProps,
      trends,
    };
  },
};
</script>
